Состояния entity в hibernate
1. Transent
2. Persistent
3. Detached

#### Transent
Временный объект, созданный через new. **Он не привязан с сессией хибера**, у него нет представления в БД и "не присвоен ID". Может быть удален garbage collector.

#### Persistent 
Постоянный экземпляр entity. Есть представление в БД, есть ID. Был либо сохранен в базу либо загружен из базы. **КРАЙТЕ ВАЖНО он находится в СЕАНСЕ.** Хибер отслеживает изменения persistent entity и может синхронизировать с БД.

#### Detached
Отсоединенный экземпляр. Переходит в состояние detached из persistent, когда закрывается сессия хибера. **ВАЖНО не находится в СЕАНСЕ.** Также можно вернуть в сеанс и перейти в состояние persistent. 
~~~java
@PersistenceContext
private EntityManager entityManager;
{
    // Проверяем, является ли сущность "detached"
    if (!entityManager.contains(model)) {
        // Если сущность "detached", "сливаем" её с текущей сессией
         model = entityManager.merge(model);
     }
}
~~~

Метод save() у data jpa, умеет работать с persistent и detached объектами.
#### Возможные ошибки
Ошибка **org.springframework.dao.InvalidDataAccessApiUsageException: detached entity passed to persist** указывает на то, что сущность, которую вы пытаетесь сохранить, уже существует в базе данных и находится в состоянии "detached". Это состояние означает, что сущность была загружена в одной сессии/транзакции, но пытается быть сохранена или изменена в другой.
#### Возможное решение
1. Проверьте состояние сущности перед сохранением: Добавьте логирование или отладочные точки, чтобы проверить состояние сущности перед ее сохранением. Убедитесь, что она действительно "detached" и что ее ID соответствует существующей записи в базе данных.
2. Проверьте каскадные операции: Если у сущности есть связи с другими сущностями, убедитесь, что каскадные операции (например, CascadeType.PERSIST, CascadeType.MERGE) настроены корректно, чтобы избежать попыток сохранения "detached" связанных сущностей.