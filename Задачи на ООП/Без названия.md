## 1. Конструктор и вызов метода `print()` в конструкторе

java

class Base {
    Base() {
        print();
    }
    void print() {
        System.out.println("Base");
    }
}

class Sub extends Base {
    int x = 1;
    Sub(int x) {
        this.x = x;
    }
    void print() {
        System.out.println(x);
    }
}

public class Test {
    public static void main(String[] args) {
        new Sub(5);
    }
}


**Что реально происходит:**

- При создании `new Sub(5)`, сначала вызывается конструктор базового класса `Base()`.
    
- В конструкторе `Base()` вызывается `print()`. Но! Из-за полиморфизма вызывается **переопределённый** метод `print()` из `Sub`.
    
- Поле `x` в `Sub` ещё не инициализировано значением `5` (конструктор `Sub` ещё не выполнился).
    
- Значение `x` по умолчанию — `0` (так как инициализация `int x = 1;` происходит после конструктора `Base`).
    
- Значит выведется `0`.
    

Пояснение:  
Порядок инициализации:

1. Все поля `Sub` по умолчанию (0 для int).
    
2. Вызов конструктора `Base()`, где вызывается `print()` из `Sub` — пока `x = 0`.
    
3. После возвращения из конструктора `Base()`, инициализация `int x = 1;`
    
4. Потом выполняется тело конструктора `Sub(int x)`, где `this.x = 5`.
    

**Вывод:**  
На экран будет выведено `0`.

## 2. Статические методы и полиморфизм

java

class A {
    static void hello() {
        System.out.println("A");
    }
}

class B extends A {
    static void hello() {
        System.out.println("B");
    }
}

public class Main {
    public static void main(String[] args) {
        A obj = new B();
        obj.hello();
    }
}


ответ:** `"B"` — неверно.

**Пояснение:**

- Статические методы в Java **не поддерживают полиморфизм**.
    
- Они вызываются исходя из типа ссылки, а не объекта.
    
- Переменная `obj` — типа `A`, поэтому вызывается `A.hello()`.
    

**Вывод:**  
Программа выведет:

text

`A`