# Чем анонимный внутренний класс отличается от лямбды?

[Посмотреть в Telegram: @JavaSobes/83](https://t.me/JavaSobes/83)

Лямбда-выражение имеет более легковесный **синтаксис**. Не нужно явно указывать тип функционального интерфейса, который лямбда реализует – он автоматически выведется из контекста. Лямбда-выражения добавлены в язык в первую очередь как синтаксический сахар.  
  
С другой стороны, **у класса есть поля**. Экземпляр анонимного класса сохраняет свое состояние между вызовами, и меняет его при необходимости. Для лямбды доступен лишь захват и [effectively final](https://stackoverflow.com/q/20938095/5521491) использование внешних переменных.  
  
**Лямбдой реализуется только функциональный интерфейс**. Функциональный интерфейс – это тип с единственным абстрактным методом. Анонимным классом же можно расширить любой расширяемый класс или реализовать интерфейс с любым количеством абстрактных методов.  
  
**Анонимный класс создает новый скоуп**, лямбда работает в текущем. Это значит, что объявление переменной с именем, которое уже используется снаружи, в лямбде вызовет ошибку компиляции «variable is already defined», в анонимном классе скроет ([shadowing](https://dzone.com/articles/variable-shadowing-and-hiding-in-java)) внешнюю переменную.  
  
С точки зрения реализации JVM, для лямбды не создается дополнительного .class файла, как это происходит для анонимного класса. Соответственно, не происходит и обычной загрузки и верификации класса. Вместо этого используется механизм `invokedynamic` и класс генерируется на лету с помощью `LambdaMetafactory`. Так что **лямбда-выражения** [обычно](https://www.oracle.com/technetwork/java/jvmls2013kuksen-2014088.pdf) **работают быстрее**. Внутренности реализации подробно разобраны например [в этой статье](https://habr.com/ru/company/haulmont/blog/432418/).