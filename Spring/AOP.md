Термины 
Cross-cutting - дополнительное действие 
Jointpoint - основное действие

виды @Advice-ов
• @Before – выполняется перед точкой входа (есть возможность и не заходить в метод) 
• @After – выполняется после точки входа (даже после исключения) 
• @Around – до и после (вокруг) - тут мы можем, сделать все что угодно в работе реальной логики метода, можем не вызвать, подменить реализацию и подменить результат, в отличии от before/after
• @AfterReturning – после того, как точка входа завершилась корректно 
• @AfterThrowing – в случае исключения в точке входа

• Можно придумать такую комбинацию упорядоченных аспектов и @AfterThrowing и @AfterReturning, что AspectJ просто не сможет создать обёртки и завершит инициализацию приложения

примеры:
![[Pasted image 20250630131737.png]]

![[Pasted image 20250630131806.png]]

![[Pasted image 20250630131826.png]]

![[Pasted image 20250630131841.png]]

![[Pasted image 20250630131856.png]]
/***********************
-pointcut - описание где искать jointPoint
Язык pointcuts 
• execution – применяется ко всем публичным методам, которые совпадают по сигнатуре 
• within – применяется ко всем публичным методам классов, которые совпадают по сигнатуре 
• target – применяется ко всем публичным методам классов, которые являются инстансом заданного класса 
• this – применяется ко всем публичным методам классов, у которых прокси заданного типа 
• bean – применяется ко всем публичным методам классов, у которых id бина соответствует заданному паттерну 
• args – применяется ко всем публичным методам, которые совпадают по сигнатуре аргументов. Аргументы определены своими типами 
• @target – применяется ко всем публичным методам классов, которые имеют над собой заданную аннотацию 
• @within – применяется ко всем публичным методам классов, которые имеют над собой заданную аннотацию 
• @annotation – применяется ко всем публичным методам, которые имеют над собой заданную аннотацию 
• @args – применяется ко всем публичным методам, которые совпадают по сигнатуре аргументов. Аргументы определены своими аннотациями 
@within и @target в Spring AOP по сути делают одно и то же, но в чистом AspectJ @within умеет в статические методы: https://stackoverflow.com/questions/51124771/difference-betweentarget-and-within-spring-aop

BEST PRACTICE использовать Pointcuts на аннотациях 
"@target(org.springframework.stereotype.Repository)" 
"@annotation(org.baeldung.aop.annotations.Loggable)"
• Являются предпочтительными • @Transactional, @Repository, @Controller так и работают • Правила приличия – они делают наличие аспекта явным
лучший способ обьявить аннотацию и ей показать явно что данный метод расширяется за счет АОП


Примеры 
execution - это для более точного указанить сигнатуры метода, класса, модификаторов доступа 
within - более лаконичная запись - без конкретики

ps. Annotation работает только для аннотаций над методами


две точки .. - это значит по любому пути, на пакет, на пакет внутри пакета - без разницы

![[Pasted image 20250630144337.png]]
![[Pasted image 20250630144819.png]]

![[Pasted image 20250630145035.png]]