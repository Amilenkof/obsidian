### Ключевые аномалии (проблемы) параллельного доступа

Прежде чем говорить об уровнях, нужно понять, **от чего они нас защищают**.

#### 1. "Грязное" чтение (Dirty Read)

> Транзакция №1 читает данные, которые были изменены транзакцией №2, но **еще не зафиксированы** (не выполнен COMMIT).

- **Риск:** Если транзакция №2 будет откатана (ROLLBACK), транзакция №1 будет работать с данными, которых никогда не существовало по-настоящему.
    

#### 2. Неповторяющееся чтение (Non-repeatable Read)

> Транзакция №1 читает одну и ту же строку **дважды** в рамках одной транзакции, и получает разные значения, потому что между этими чтениями транзакция №2 **изменила** эту строку и зафиксировала изменения.

- **Риск:** Данные "уплывают" во время работы транзакции, что может привести к логическим ошибкам.
    

#### 3. Фантомное чтение (Phantom Read)

> Транзакция №1 дважды выполняет один и тот же запрос с условием (например, `WHERE status = 'active'`), и получает разное **количество строк**, потому что между выполнениями транзакция №2 **добавила** или **удалила** строки, удовлетворяющие этому условию, и зафиксировала изменения.

- **Риск:** Появление "фантомных" строк нарушает логику транзакции, которая рассчитывала на неизменность набора данных.
    

---

### Уровни изоляции (от самого слабого к самому строгому)

Уровни изоляции определяют, какие аномалии мы допускаем, а какие — нет. Стандарт SQL определяет 4 уровня.

#### 1. Read Uncommitted (Чтение незафиксированных данных)

- **Девиз:** "Максимальная производительность, нулевая согласованность".
    
- **Как работает:** Транзакция может читать данные, которые были изменены другой транзакцией, но еще не зафиксированы.
    
- **Разрешенные аномалии:**
    
    - ✅ **Грязное чтение (Dirty Read)**
        
    - ✅ **Неповторяющееся чтение (Non-repeatable Read)**
        
    - ✅ **Фантомное чтение (Phantom Read)**
        
- **Когда использовать?** Практически никогда. Подходит только для агрегатной аналитики, где не нужна абсолютная точность (например, примерный подсчет количества записей).
    

#### 2. Read Committed (Чтение зафиксированных данных)

- **Девиз:** "Читаем только то, что уже подтверждено".
    
- **Как работает:** Транзакция может читать только те данные, которые были зафиксированы другими транзакциями. Это уровень по умолчанию во многих СУБД (например, в PostgreSQL, Oracle).
    
- **Разрешенные аномалии:**
    
    - ❌ **Грязное чтение (Dirty Read)**
        
    - ✅ **Неповторяющееся чтение (Non-repeatable Read)**
        
    - ✅ **Фантомное чтение (Phantom Read)**
        
- **Когда использовать?** Подходит для многих приложений, где не критично, если данные немного изменятся во время работы транзакции.
    

#### 3. Repeatable Read (Повторяемое чтение)

- **Девиз:** "Прочитанные мной данные не изменятся".
    
- **Как работает:** Гарантирует, что любые строки, прочитанные в течение транзакции, не будут изменены другими транзакциями до ее завершения. Однако новые строки могут быть добавлены.
    
- **Разрешенные аномалии:**
    
    - ❌ **Грязное чтение (Dirty Read)**
        
    - ❌ **Неповторяющееся чтение (Non-repeatable Read)**
        
    - ✅ **Фантомное чтение (Phantom Read)**
        
- **Когда использовать?** Когда важно, чтобы набор прочитанных в транзакции строк оставался неизменным (например, при подсчете общего баланса по нескольким счетам). Уровень по умолчанию в MySQL (InnoDB).
    

**Важное замечание для MySQL/InnoDB:** На этом уровне благодаря механизму **MVCC (Multiversion Concurrency Control)** фантомное чтение также предотвращается, что является расширением стандарта.

#### 4. Serializable (Сериализуемый)

- **Девиз:** "Полная изоляция, как будто транзакции выполняются строго одна за другой".
    
- **Как работает:** Самый строгий уровень. Гарантирует, что результат параллельного выполнения транзакций будет точно таким же, как если бы они выполнялись последовательно. Часто достигается за счет полной блокировки диапазонов данных.
    
- **Разрешенные аномалии:**
    
    - ❌ **Грязное чтение (Dirty Read)**
        
    - ❌ **Неповторяющееся чтение (Non-repeatable Read)**
        
    - ❌ **Фантомное чтение (Phantom Read)**
        
- **Когда использовать?** Для критически важных финансовых операций, где любая аномалия недопустима. Сильно снижает производительность из-за высокого уровня блокировок.
    

---

### Сводная таблица уровней изоляции и аномалий

|Уровень изоляции|Грязное чтение|Неповторяющееся чтение|Фантомное чтение|
|---|---|---|---|
|**Read Uncommitted**|✅ (возможно)|✅ (возможно)|✅ (возможно)|
|**Read Committed**|❌|✅ (возможно)|✅ (возможно)|
|**Repeatable Read**|❌|❌|✅ (возможно)*|
|**Serializable**|❌|❌|❌|

*В MySQL/InnoDB на уровне Repeatable Read фантомное чтение также предотвращается.

---

### Практический пример

Представьте двух пользователей, работающих с базой данных банка.

1. **Транзакция А (перевод денег):**
    
    sql
    
    START TRANSACTION;
    UPDATE accounts SET balance = balance - 100 WHERE user_id = 1; -- Списание
    UPDATE accounts SET balance = balance + 100 WHERE user_id = 2; -- Зачисление
    -- Пока COMMIT не выполнен!
    
2. **Транзакция Б (проверка баланса):**
    
    sql
    
    START TRANSACTION;
    SELECT balance FROM accounts WHERE user_id = 1; -- Чтение
    COMMIT;
    

- **При `Read Uncommitted`:** Транзакция Б увидит новое (уменьшенное) значение баланса пользователя 1, даже если Транзакция А потом откатится. Это **грязное чтение**.
    
- **При `Read Committed`:** Транзакция Б будет ждать, пока Транзакция А не сделает COMMIT или ROLLBACK, и только потом прочитает актуальные зафиксированные данные. Грязного чтения не будет.
    

---

### Как выбирать уровень изоляции?

1. **Начните с уровня по умолчанию** для вашей СУБД (обычно `Read Committed`).
    
2. **Переходите на более строгий уровень (`Repeatable Read` или `Serializable`) только при необходимости**, когда вы обнаруживаете логические ошибки в приложении, связанные с параллельным доступом.
    
3. **Помните о компромиссе:** Чем строже уровень, тем больше блокировок, выше вероятность взаимных ожиданий (deadlocks) и ниже общая пропускная способность системы.
    

Понимание уровней изоляции позволяет находить баланс между целостностью данных и производительностью вашего приложения.