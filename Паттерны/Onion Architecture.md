Что такое Onion Architecture?

Onion Architecture — это архитектурный подход, который разделяет систему на несколько слоёв, каждый из которых выполняет свою функцию. Эти слои представляют собой «шелуху» лука, где внутренний слой (ядро) содержит бизнес-логику и данные, а внешние слои отвечают за взаимодействие с пользователем, доступ к данным и другие функции.  
  
Основные принципы Onion Architecture включают в себя:  
  
1. **Ядро (Core)** — внутренний слой, содержащий бизнес-правила и логику приложения. Этот слой не должен зависеть от внешних факторов, таких как пользовательский интерфейс или базы данных.  
2. **Инфраструктура (Infrastructure)** — слой, отвечающий за доступ к внешним ресурсам, таким как базы данных, очереди сообщений и т. д. Этот слой может быть реализован с использованием различных технологий, таких как ORM, микросервисы и т. п.  
3. **Адаптеры (Adapters)** — слой, обеспечивающий взаимодействие между ядром и инфраструктурой. Адаптеры могут быть реализованы в виде библиотек, фреймворков или других компонентов.  
4. **Презентация (Presentation)** — внешний слой, представляющий пользовательский интерфейс и взаимодействующий с адаптерами. Этот слой отвечает за отображение данных и обработку пользовательских запросов.

![](https://optim.tildacdn.com/tild6363-3762-4335-b731-356364383866/-/resize/560x/-/format/webp/__2024-06-05__002257.png.webp)

Преимущества Onion Architecture

- **Гибкость**: благодаря разделению на слои, система становится более гибкой и легко адаптируемой к изменениям требований.
- **Масштабируемость**: каждый слой можно масштабировать независимо друг от друга, что позволяет оптимизировать производительность системы.
- **Тестируемость**: разделение на слои упрощает тестирование каждого компонента отдельно.
- **Поддержка**: благодаря чёткому разделению функций, разработчики могут легче поддерживать и обновлять систему.


Типичная структура пакетов в Java-приложении, реализующем луковую (Onion) архитектуру, может выглядеть так:

text
![[Pasted image 20250904000112.png]]
## Основные принципы и описание:

- **domain** — содержит сущности (Entity), бизнес-логику и доменные сервисы. Слой не зависит ни от каких других слоев.
    
- **application** — реализует сценарии использования (use cases), содержит интерфейсы портов и DTO для передачи данных между слоями и наружу.
    
- **infrastructure** — конкретные реализации интерфейсов, работа с БД, внешними API, файловыми системами.
    
- **presentation** — REST API контроллеры, принимают запросы и возвращают DTO, используя слой application.
    

Такое разделение позволяет менять реализацию инфраструктуры (например, базу данных) без влияния на бизнес-логику, а также легко расширять или модифицировать API и представление без нарушения ядра приложения.

В структуре кода каждый пакет отвечает за строго определённый уровень абстракции, а зависимости направлены внутрь (от внешних слоёв к внутренним).

Эта структура соответствует рекомендациям луковой архитектуры и применяется в крупных корпоративных Java-проектах для повышения устойчивости и тестируемости кода.[habr+2](https://habr.com/ru/articles/427739/)

1. [https://habr.com/ru/articles/427739/](https://habr.com/ru/articles/427739/)
2. [https://microarch.ru/blog/onion-architecture](https://microarch.ru/blog/onion-architecture)
3. [https://ru.stackoverflow.com/questions/680014/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%BE%D0%B2-%D0%B2-clean-architecture](https://ru.stackoverflow.com/questions/680014/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%BE%D0%B2-%D0%B2-clean-architecture)
4. [https://tproger.ru/articles/onion-architecture-251413](https://tproger.ru/articles/onion-architecture-251413)
5. [https://habr.com/ru/articles/718916/](https://habr.com/ru/articles/718916/)
6. [https://www.reddit.com/r/golang/comments/1h7jajk/why_clean_architecture_and_overengineered/?tl=ru](https://www.reddit.com/r/golang/comments/1h7jajk/why_clean_architecture_and_overengineered/?tl=ru)